// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/yoda/common/pkg/types"
)

const (
	HeaderApiKeyScopes = "HeaderApiKey.Scopes"
)

// Defines values for FBOStatus.
const (
	AwaitingDeliver   FBOStatus = "awaiting_deliver"
	AwaitingPackaging FBOStatus = "awaiting_packaging"
	Cancelled         FBOStatus = "cancelled"
	Delivered         FBOStatus = "delivered"
	Delivering        FBOStatus = "delivering"
)

// Defines values for ProductAttributeFilterFilterVisibility.
const (
	ProductAttributeFilterFilterVisibilityALL                    ProductAttributeFilterFilterVisibility = "ALL"
	ProductAttributeFilterFilterVisibilityARCHIVED               ProductAttributeFilterFilterVisibility = "ARCHIVED"
	ProductAttributeFilterFilterVisibilityBANNED                 ProductAttributeFilterFilterVisibility = "BANNED"
	ProductAttributeFilterFilterVisibilityBARCODEEXISTS          ProductAttributeFilterFilterVisibility = "BARCODE_EXISTS"
	ProductAttributeFilterFilterVisibilityCRITICALLYOVERPRICED   ProductAttributeFilterFilterVisibility = "CRITICALLY_OVERPRICED"
	ProductAttributeFilterFilterVisibilityDISABLED               ProductAttributeFilterFilterVisibility = "DISABLED"
	ProductAttributeFilterFilterVisibilityEMPTYBARCODE           ProductAttributeFilterFilterVisibility = "EMPTY_BARCODE"
	ProductAttributeFilterFilterVisibilityEMPTYSTOCK             ProductAttributeFilterFilterVisibility = "EMPTY_STOCK"
	ProductAttributeFilterFilterVisibilityIMAGEABSENT            ProductAttributeFilterFilterVisibility = "IMAGE_ABSENT"
	ProductAttributeFilterFilterVisibilityINSALE                 ProductAttributeFilterFilterVisibility = "IN_SALE"
	ProductAttributeFilterFilterVisibilityINVISIBLE              ProductAttributeFilterFilterVisibility = "INVISIBLE"
	ProductAttributeFilterFilterVisibilityMODERATED              ProductAttributeFilterFilterVisibility = "MODERATED"
	ProductAttributeFilterFilterVisibilityMODERATIONBLOCK        ProductAttributeFilterFilterVisibility = "MODERATION_BLOCK"
	ProductAttributeFilterFilterVisibilityNOTMODERATED           ProductAttributeFilterFilterVisibility = "NOT_MODERATED"
	ProductAttributeFilterFilterVisibilityOVERPRICED             ProductAttributeFilterFilterVisibility = "OVERPRICED"
	ProductAttributeFilterFilterVisibilityOVERPRICEDWITHSTOCK    ProductAttributeFilterFilterVisibility = "OVERPRICED_WITH_STOCK"
	ProductAttributeFilterFilterVisibilityPARTIALAPPROVED        ProductAttributeFilterFilterVisibility = "PARTIAL_APPROVED"
	ProductAttributeFilterFilterVisibilityQUARANTINE             ProductAttributeFilterFilterVisibility = "QUARANTINE"
	ProductAttributeFilterFilterVisibilityREADYTOSUPPLY          ProductAttributeFilterFilterVisibility = "READY_TO_SUPPLY"
	ProductAttributeFilterFilterVisibilityREMOVEDFROMSALE        ProductAttributeFilterFilterVisibility = "REMOVED_FROM_SALE"
	ProductAttributeFilterFilterVisibilitySTATEFAILED            ProductAttributeFilterFilterVisibility = "STATE_FAILED"
	ProductAttributeFilterFilterVisibilityTOSUPPLY               ProductAttributeFilterFilterVisibility = "TO_SUPPLY"
	ProductAttributeFilterFilterVisibilityVALIDATIONSTATEFAIL    ProductAttributeFilterFilterVisibility = "VALIDATION_STATE_FAIL"
	ProductAttributeFilterFilterVisibilityVALIDATIONSTATEPENDING ProductAttributeFilterFilterVisibility = "VALIDATION_STATE_PENDING"
	ProductAttributeFilterFilterVisibilityVALIDATIONSTATESUCCESS ProductAttributeFilterFilterVisibility = "VALIDATION_STATE_SUCCESS"
	ProductAttributeFilterFilterVisibilityVISIBLE                ProductAttributeFilterFilterVisibility = "VISIBLE"
)

// Defines values for GetOzonSupplierStocksJSONBodyWarehouseType.
const (
	GetOzonSupplierStocksJSONBodyWarehouseTypeALL                 GetOzonSupplierStocksJSONBodyWarehouseType = "ALL"
	GetOzonSupplierStocksJSONBodyWarehouseTypeEXPRESSDARKSTORE    GetOzonSupplierStocksJSONBodyWarehouseType = "EXPRESS_DARK_STORE"
	GetOzonSupplierStocksJSONBodyWarehouseTypeNOTEXPRESSDARKSTORE GetOzonSupplierStocksJSONBodyWarehouseType = "NOT_EXPRESS_DARK_STORE"
)

// AdditionalDataItem defines model for AdditionalDataItem.
type AdditionalDataItem struct {
	// Key Название дополнительного поля
	Key *string `json:"key,omitempty"`

	// Value Значение дополнительного поля
	Value *string `json:"value,omitempty"`
}

// FBO defines model for FBO.
type FBO struct {
	// AdditionalData Дополнительные данные
	AdditionalData *[]AdditionalDataItem              `json:"additional_data,omitempty"`
	AnalyticsData  *FboPostingFboPostingAnalyticsData `json:"analytics_data,omitempty"`

	// CancelReasonId Идентификатор причины отмены
	CancelReasonId *int `json:"cancel_reason_id,omitempty"`

	// CreatedAt Дата создания
	CreatedAt     time.Time             `json:"created_at"`
	FinancialData *PostingFinancialData `json:"financial_data,omitempty"`

	// InProcessAt Дата начала обработки
	InProcessAt *time.Time `json:"in_process_at,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int64 `json:"order_id,omitempty"`

	// OrderNumber Номер заказа
	OrderNumber *string `json:"order_number,omitempty"`

	// PostingNumber Номер отправления
	PostingNumber *string `json:"posting_number,omitempty"`

	// Products Список товаров в заказе.
	Products *[]PostingProduct `json:"products,omitempty"`

	// ShipmentDate Дата отгрузки
	ShipmentDate string `json:"shipment_date"`

	// Status Статус отправления.
	Status FBOStatus `json:"status"`
}

// FBOStatus Статус отправления.
type FBOStatus string

// FBOFilter defines model for FBOFilter.
type FBOFilter struct {
	// Dir Направление сортировки. Возможные значения: `asc` - по возрастанию,`desc` - по убыванию.
	Dir    string          `json:"dir"`
	Filter FBOFilterFilter `json:"filter"`

	// Limit Количество записей на странице
	Limit int64 `json:"limit"`

	// Offset Смещение от начала списка
	Offset int64 `json:"offset"`

	// Translit Флаг транслитерации названий городов
	Translit bool          `json:"translit"`
	With     FBOFilterWith `json:"with"`
}

// FBOFilterFilter defines model for FBOFilterFilter.
type FBOFilterFilter struct {
	// Since Начало периода в формате YYYY-MM-DD
	Since time.Time `json:"since"`

	// Status Статус отправления. awaiting_packaging — ожидает упаковки, awaiting_deliver — ожидает отгрузки, delivering — доставляется, delivered — доставлено, cancelled — отменено.
	Status string `json:"status"`

	// To Конец периода в формате YYYY-MM-DD
	To time.Time `json:"to"`
}

// FBOFilterWith defines model for FBOFilterWith.
type FBOFilterWith struct {
	// AnalyticsData Флаг включения данных аналитики
	AnalyticsData bool `json:"analytics_data"`

	// FinancialData Флаг включения финансовых данных
	FinancialData bool `json:"financial_data"`
}

// FboPostingFboPostingAnalyticsData defines model for FboPostingFboPostingAnalyticsData.
type FboPostingFboPostingAnalyticsData struct {
	// City Город
	City *string `json:"city,omitempty"`

	// DeliveryType Тип доставки
	DeliveryType *string `json:"delivery_type,omitempty"`

	// IsLegal Флаг юридического лица
	IsLegal *bool `json:"is_legal,omitempty"`

	// IsPremium Флаг премиума
	IsPremium *bool `json:"is_premium,omitempty"`

	// PaymentTypeGroupName Группа типа оплаты
	PaymentTypeGroupName *string `json:"payment_type_group_name,omitempty"`

	// Region Регион
	Region *string `json:"region,omitempty"`

	// WarehouseId Идентификатор склада
	WarehouseId *int64 `json:"warehouse_id,omitempty"`

	// WarehouseName Название склада
	WarehouseName *string `json:"warehouse_name,omitempty"`
}

// OrdersItem defines model for OrdersItem.
type OrdersItem struct {
	// Barcode Бар-код
	Barcode *string `json:"barcode,omitempty"`

	// Brand Бренд
	Brand *string `json:"brand,omitempty"`

	// CancelDt Дата и время отмены заказа. Если заказ не был отменен, то `"0001-01-01T00:00:00"`. Если часовой пояс не указан, то берется Московское время UTC+3.
	CancelDt *types.CustomTime `json:"cancel_dt,omitempty"`

	// Category Категория
	Category *string `json:"category,omitempty"`

	// Date Дата и время заказа. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=1`. Если часовой пояс не указан, то берется Московское время UTC+3.
	Date *types.CustomTime `json:"date,omitempty"`

	// DiscountPercent Согласованный итоговый дисконт. Будучи примененным к `totalPrice`, даёт сумму к оплате.
	DiscountPercent *int `json:"discountPercent,omitempty"`

	// GNumber Номер заказа. Объединяет все позиции одного заказа.
	GNumber *string `json:"gNumber,omitempty"`

	// IncomeID Номер поставки (от продавца на склад)
	IncomeID *int64 `json:"incomeID,omitempty"`

	// IsCancel Отмена заказа. true - заказ отменен до оплаты.
	IsCancel *bool `json:"isCancel,omitempty"`

	// LastChangeDate Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=0` или не указан. Если часовой пояс не указан, то берется Московское время UTC+3.
	LastChangeDate *types.CustomTime `json:"lastChangeDate,omitempty"`

	// NmId Код WB
	NmId *int `json:"nmId,omitempty"`

	// Oblast Область
	Oblast *string `json:"oblast,omitempty"`

	// Srid Уникальный идентификатор заказа, функционально аналогичный `odid`/`rid`.  Данный параметр введен в июле'22 и в течение переходного периода может быть заполнен не во всех ответах. Примечание для работающих по системе Маркетплейс: `srid` равен `rid` в ответе на метод `GET /api/v2/orders`.
	Srid *string `json:"srid,omitempty"`

	// Sticker Цифровое значение стикера, который клеится на товар в процессе сборки заказа по системе Маркетплейс.
	Sticker *string `json:"sticker,omitempty"`

	// Subject Предмет
	Subject *string `json:"subject,omitempty"`

	// SupplierArticle Артикул поставщика
	SupplierArticle *string `json:"supplierArticle,omitempty"`

	// TechSize Размер
	TechSize *string `json:"techSize,omitempty"`

	// TotalPrice Цена до согласованной итоговой скидки/промо/спп. Для получения цены со скидкой можно воспользоваться формулой `priceWithDiscount = totalPrice * (1 - discountPercent/100)`
	TotalPrice *float64 `json:"totalPrice,omitempty"`

	// WarehouseName Название склада отгрузки
	WarehouseName *string `json:"warehouseName,omitempty"`
}

// OzonError defines model for OzonError.
type OzonError struct {
	// Code Код ошибки
	Code *int `json:"code,omitempty"`

	// Details Дополнительные данные, обогащающие ошибку
	Details *[]struct {
		TypeUrl *string `json:"typeUrl,omitempty"`
		Value   *string `json:"value,omitempty"`
	} `json:"details,omitempty"`

	// Message Описание ошибки
	Message *string `json:"message,omitempty"`
}

// PostingFinancialData defines model for PostingFinancialData.
type PostingFinancialData struct {
	// Products Список товаров в заказе.
	Products *[]PostingFinancialDataProduct `json:"products,omitempty"`
}

// PostingFinancialDataProduct defines model for PostingFinancialDataProduct.
type PostingFinancialDataProduct struct {
	// CommissionAmount Сумма комиссии
	CommissionAmount *float64 `json:"commission_amount,omitempty"`

	// CommissionPercent Процент комиссии
	CommissionPercent *int64 `json:"commission_percent,omitempty"`

	// CommissionsCurrencyCode Код валюты комиссии
	CommissionsCurrencyCode *string `json:"commissions_currency_code,omitempty"`

	// CurrencyCode Код валюты
	CurrencyCode *string `json:"currency_code,omitempty"`

	// OldPrice Цена до учёта скидок. На карточке товара отображается зачёркнутой.
	OldPrice float64 `json:"old_price"`

	// Price Цена товара
	Price float64 `json:"price"`

	// ProductId Идентификатор товара
	ProductId int64 `json:"product_id"`

	// TotalDiscountPercent Общий процент скидки
	TotalDiscountPercent float64 `json:"total_discount_percent"`

	// TotalDiscountValue Общая сумма скидки
	TotalDiscountValue float64 `json:"total_discount_value"`
}

// PostingProduct defines model for PostingProduct.
type PostingProduct struct {
	// CurrencyCode Код валюты
	CurrencyCode *string `json:"currency_code,omitempty"`

	// Name Наименование товара
	Name *string `json:"name,omitempty"`

	// OfferId Идентификатор товара
	OfferId string `json:"offer_id"`

	// Price Цена товара
	Price string `json:"price"`

	// Quantity Количество товара
	Quantity int64 `json:"quantity"`

	// Sku Артикул товара
	Sku int64 `json:"sku"`
}

// ProductAttribute defines model for ProductAttribute.
type ProductAttribute struct {
	Attributes *[]ProductAttributesComplexAttribute `json:"attributes,omitempty"`

	// Barcode Штрихкод.
	Barcode *string `json:"barcode,omitempty"`

	// CategoryId Идентификатор категории.
	CategoryId *int `json:"category_id,omitempty"`

	// ColorImage Маркетинговый цвет.
	ColorImage        *string                              `json:"color_image,omitempty"`
	ComplexAttributes *[]ProductAttributesComplexAttribute `json:"complex_attributes,omitempty"`

	// Depth Глубина.
	Depth *int `json:"depth,omitempty"`

	// DimensionUnit Единица измерения габаритов
	DimensionUnit *string `json:"dimension_unit,omitempty"`

	// Height Высота упаковки.
	Height *int `json:"height,omitempty"`

	// Id Идентификатор характеристики товара.
	Id *int `json:"id,omitempty"`

	// ImageGroupId Идентификатор для последующей пакетной загрузки изображений.
	ImageGroupId *string                   `json:"image_group_id,omitempty"`
	Images       *[]ProductAttributesImage `json:"images,omitempty"`

	// Name Название товара. До 500 символов.
	Name *string `json:"name,omitempty"`

	// OfferId Идентификатор товара в системе продавца — артикул.
	OfferId *string `json:"offer_id,omitempty"`

	// Weight Вес товара в упаковке.
	Weight *int `json:"weight,omitempty"`

	// WeightUnit Единица измерения веса.
	WeightUnit *string `json:"weight_unit,omitempty"`

	// Width Ширина упаковки.
	Width *int `json:"width,omitempty"`
}

// ProductAttributeFilter defines model for ProductAttributeFilter.
type ProductAttributeFilter struct {
	Filter *ProductAttributeFilterFilter `json:"filter,omitempty"`

	// LastId Идентификатор последнего значения на странице. Оставьте это поле пустым при выполнении первого запроса.Чтобы получить следующие значения, укажите last_id из ответа предыдущего запроса.
	LastId *string `json:"last_id,omitempty"`

	// Limit Количество значений на странице. Минимум — 1, максимум — 1000.
	Limit   *int    `json:"limit,omitempty"`
	SortBy  *string `json:"sort_by,omitempty"`
	SortDir *string `json:"sort_dir,omitempty"`
}

// ProductAttributeFilterFilter defines model for ProductAttributeFilterFilter.
type ProductAttributeFilterFilter struct {
	OfferId    *[]string                               `json:"offer_id,omitempty"`
	ProductId  *[]int                                  `json:"product_id,omitempty"`
	Visibility *ProductAttributeFilterFilterVisibility `json:"visibility,omitempty"`
}

// ProductAttributeFilterFilterVisibility defines model for ProductAttributeFilterFilter.Visibility.
type ProductAttributeFilterFilterVisibility string

// ProductAttributesComplexAttribute defines model for ProductAttributesComplexAttribute.
type ProductAttributesComplexAttribute struct {
	// AttributeId Идентификатор характеристики.
	AttributeId *int `json:"attribute_id,omitempty"`

	// ComplexId Идентификатор характеристики, которая поддерживает вложенные свойства. Например, у характеристики «Процессор» есть вложенные характеристики «Производитель» и «L2 Cache». У каждой из вложенных характеристик может быть несколько вариантов значений.
	ComplexId *int                                `json:"complex_id,omitempty"`
	Values    *[]ProductAttributesDictionaryValue `json:"values,omitempty"`
}

// ProductAttributesDictionaryValue defines model for ProductAttributesDictionaryValue.
type ProductAttributesDictionaryValue struct {
	DictionaryValueId *int    `json:"dictionaryValueId,omitempty"`
	Value             *string `json:"value,omitempty"`
}

// ProductAttributesImage defines model for ProductAttributesImage.
type ProductAttributesImage struct {
	Default  *bool   `json:"default,omitempty"`
	FileName *string `json:"file_name,omitempty"`
	Index    *int    `json:"index,omitempty"`
}

// ProductFilter defines model for ProductFilter.
type ProductFilter struct {
	OfferId   *[]string `json:"offer_id,omitempty"`
	ProductId *[]string `json:"product_id,omitempty"`
	Sku       *[]int64  `json:"sku,omitempty"`
}

// ProductInfo defines model for ProductInfo.
type ProductInfo struct {
	Barcode        *string    `json:"barcode,omitempty"`
	Barcodes       *[]string  `json:"barcodes,omitempty"`
	BuyboxPrice    *string    `json:"buybox_price,omitempty"`
	CategoryId     *int       `json:"category_id,omitempty"`
	CreatedAt      *time.Time `json:"created_at,omitempty"`
	CurrencyCode   *string    `json:"currency_code,omitempty"`
	FboSku         *int64     `json:"fbo_sku,omitempty"`
	Id             *int       `json:"id,omitempty"`
	MarketingPrice *string    `json:"marketing_price,omitempty"`
	MinPrice       *string    `json:"min_price,omitempty"`
	Name           *string    `json:"name,omitempty"`
	OfferId        *string    `json:"offer_id,omitempty"`
	OldPrice       *string    `json:"old_price,omitempty"`
	Vat            *string    `json:"vat,omitempty"`
}

// ReportDetailByPeriodItem defines model for ReportDetailByPeriodItem.
type ReportDetailByPeriodItem struct {
	// AcquiringBank Наименование банка, предоставляющего услуги эквайринга
	AcquiringBank *string `json:"acquiring_bank,omitempty"`

	// AcquiringFee Возмещение расходов по эквайрингу
	AcquiringFee *float64 `json:"acquiring_fee,omitempty"`

	// AdditionalPayment Доплаты
	AdditionalPayment *float64 `json:"additional_payment,omitempty"`

	// Barcode Баркод
	Barcode *string `json:"barcode,omitempty"`

	// BonusTypeName Обоснование штрафов и доплат
	BonusTypeName *string `json:"bonus_type_name,omitempty"`

	// BrandName Бренд
	BrandName *string `json:"brand_name,omitempty"`

	// CommissionPercent Процент комиссии
	CommissionPercent *float64 `json:"commission_percent,omitempty"`

	// CreateDt Дата формирования отчёта
	CreateDt *types.CustomTime `json:"create_dt,omitempty"`

	// DateFrom Дата начала отчётного периода
	DateFrom *types.CustomTime `json:"date_from,omitempty"`

	// DateTo Дата конца отчётного периода
	DateTo *types.CustomTime `json:"date_to,omitempty"`

	// DeclarationNumber Номер таможенной декларации
	DeclarationNumber *string `json:"declaration_number,omitempty"`

	// DeliveryAmount Количество доставок
	DeliveryAmount *int64 `json:"delivery_amount,omitempty"`

	// DeliveryRub Стоимость логистики
	DeliveryRub *float64 `json:"delivery_rub,omitempty"`

	// DocNumber Номер документа
	DocNumber *string `json:"doc_number,omitempty"`

	// DocTypeName Тип документа
	DocTypeName *string `json:"doc_type_name,omitempty"`

	// GiBoxTypeName Тип коробов
	GiBoxTypeName *string `json:"gi_box_type_name,omitempty"`

	// GiId Номер поставки
	GiId *int64 `json:"gi_id,omitempty"`

	// Kiz Код маркировки
	Kiz *string `json:"kiz,omitempty"`

	// NmId Номер номенклатуры
	NmId *int64 `json:"nm_id,omitempty"`

	// OfficeName Склад
	OfficeName *string `json:"office_name,omitempty"`

	// OrderDt Дата заказа
	OrderDt *types.CustomTime `json:"order_dt,omitempty"`

	// Penalty Штрафы
	Penalty *float64 `json:"penalty,omitempty"`

	// PpvzForPay К перечислению продавцу за реализованный товар
	PpvzForPay *float64 `json:"ppvz_for_pay,omitempty"`

	// PpvzInn ИНН партнера
	PpvzInn *string `json:"ppvz_inn,omitempty"`

	// PpvzKvwPrc Размер кВВ без НДС, %
	PpvzKvwPrc *float64 `json:"ppvz_kvw_prc,omitempty"`

	// PpvzKvwPrcBase Размер кВВ без НДС, % базовый
	PpvzKvwPrcBase *float64 `json:"ppvz_kvw_prc_base,omitempty"`

	// PpvzOfficeId Номер офиса
	PpvzOfficeId *int64 `json:"ppvz_office_id,omitempty"`

	// PpvzOfficeName Наименование офиса доставки
	PpvzOfficeName *string `json:"ppvz_office_name,omitempty"`

	// PpvzReward Вознаграждение за выдачу и возврат товаров на ПВЗ
	PpvzReward *float64 `json:"ppvz_reward,omitempty"`

	// PpvzSalesCommission Вознаграждение с продаж до вычета услуг поверенного, без НДC
	PpvzSalesCommission *float64 `json:"ppvz_sales_commission,omitempty"`

	// PpvzSppPrc Стоимость доставки на ПВЗ
	PpvzSppPrc *float64 `json:"ppvz_spp_prc,omitempty"`

	// PpvzSupplierId Номер партнера
	PpvzSupplierId *int64 `json:"ppvz_supplier_id,omitempty"`

	// PpvzSupplierName Наименование партнера
	PpvzSupplierName *string `json:"ppvz_supplier_name,omitempty"`

	// PpvzVw Вознаграждение WB без НДС
	PpvzVw *float64 `json:"ppvz_vw,omitempty"`

	// PpvzVwNds Вознаграждение WB с НДС
	PpvzVwNds *float64 `json:"ppvz_vw_nds,omitempty"`

	// ProductDiscountForReport Согласованный продуктовый дисконт
	ProductDiscountForReport *float64 `json:"product_discount_for_report,omitempty"`

	// Quantity Количество
	Quantity *int64 `json:"quantity,omitempty"`

	// RealizationreportId Номер отчёта
	RealizationreportId *int64 `json:"realizationreport_id,omitempty"`

	// RetailAmount Сумма продаж (возвратов)
	RetailAmount *float64 `json:"retail_amount,omitempty"`

	// RetailPrice Цена розничная
	RetailPrice *float64 `json:"retail_price,omitempty"`

	// RetailPriceWithdiscRub Цена розничная с учетом согласованной скидки
	RetailPriceWithdiscRub *float64 `json:"retail_price_withdisc_rub,omitempty"`

	// ReturnAmount Количество возвратов
	ReturnAmount *int64 `json:"return_amount,omitempty"`

	// Rid Уникальный идентификатор заказа
	Rid *int64 `json:"rid,omitempty"`

	// RrDt Дата операции
	RrDt *types.CustomTime `json:"rr_dt,omitempty"`

	// RrdId Номер строки
	RrdId *int64 `json:"rrd_id,omitempty"`

	// SaName Артикул продавца
	SaName *string `json:"sa_name,omitempty"`

	// SaleDt Дата продажи
	SaleDt *types.CustomTime `json:"sale_dt,omitempty"`

	// SalePercent Согласованная скидка
	SalePercent *float64 `json:"sale_percent,omitempty"`

	// ShkId Номер штрих-кода
	ShkId *int64 `json:"shk_id,omitempty"`

	// SiteCountry Страна продажи
	SiteCountry *string `json:"site_country,omitempty"`

	// Srid Уникальный идентификатор заказа
	Srid *string `json:"srid,omitempty"`

	// StickerId Цифровое значение стикера, который клеится на товар в процессе сборки заказа по схеме "Маркетплейс"
	StickerId *string `json:"sticker_id,omitempty"`

	// SubjectName Наименование предмета
	SubjectName *string `json:"subject_name,omitempty"`

	// SupplierOperName Обоснование для оплаты
	SupplierOperName *string `json:"supplier_oper_name,omitempty"`

	// SupplierPromo Скидка поставщика
	SupplierPromo *float64 `json:"supplier_promo,omitempty"`

	// SuppliercontractCode Номер договора
	SuppliercontractCode *string `json:"suppliercontract_code,omitempty"`

	// TsName Артикул поставщика
	TsName *string `json:"ts_name,omitempty"`
}

// RowItem defines model for RowItem.
type RowItem struct {
	FreeToSellAmount *int    `json:"free_to_sell_amount,omitempty"`
	ItemCode         *string `json:"item_code,omitempty"`
	ItemName         *string `json:"item_name,omitempty"`
	PromisedAmount   *int    `json:"promised_amount,omitempty"`
	ReservedAmount   *int    `json:"reserved_amount,omitempty"`
	Sku              *int64  `json:"sku,omitempty"`
	WarehouseName    *string `json:"warehouse_name,omitempty"`
}

// SalesItem defines model for SalesItem.
type SalesItem struct {
	// Barcode Бар-код
	Barcode *string `json:"barcode,omitempty"`

	// Brand Бренд
	Brand *string `json:"brand,omitempty"`

	// Category Категория
	Category *string `json:"category,omitempty"`

	// CountryName Страна
	CountryName *string `json:"countryName,omitempty"`

	// Date Дата и время продажи. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=1`. Если часовой пояс не указан, то берется Московское время UTC+3.
	Date *string `json:"date,omitempty"`

	// DiscountPercent Согласованный итоговый дисконт
	DiscountPercent *int `json:"discountPercent,omitempty"`

	// FinishedPrice Фактическая цена заказа с учетом всех скидок
	FinishedPrice *float32 `json:"finishedPrice,omitempty"`

	// ForPay К перечислению поставщику
	ForPay *float32 `json:"forPay,omitempty"`

	// GNumber Номер заказа. Объединяет все позиции одного заказа.
	GNumber *string `json:"gNumber,omitempty"`

	// IncomeID Номер поставки (от продавца на склад)
	IncomeID *int64 `json:"incomeID,omitempty"`

	// IsRealization Договор реализации
	IsRealization *bool `json:"isRealization,omitempty"`

	// IsStorno Для сторно-операций `1`, для остальных `0`
	IsStorno *int `json:"isStorno,omitempty"`

	// IsSupply Договор поставки
	IsSupply *bool `json:"isSupply,omitempty"`

	// LastChangeDate Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=0` или не указан. Если часовой пояс не указан, то берется Московское время UTC+3.
	LastChangeDate *types.CustomTime `json:"lastChangeDate,omitempty"`

	// NmId Код WB
	NmId *int `json:"nmId,omitempty"`

	// OblastOkrugName Округ
	OblastOkrugName *string `json:"oblastOkrugName,omitempty"`

	// Odid Уникальный идентификатор позиции заказа. Может использоваться для поиска соответствия между заказами и продажами.
	Odid *int64 `json:"odid,omitempty"`

	// PriceWithDisc Цена, от которой считается вознаграждение поставщика `forpay` (с учетом всех согласованных скидок)
	PriceWithDisc *float32 `json:"priceWithDisc,omitempty"`

	// PromoCodeDiscount Скидка по промокоду
	PromoCodeDiscount *float64 `json:"promoCodeDiscount,omitempty"`

	// RegionName Регион
	RegionName *string `json:"regionName,omitempty"`

	// SaleID Уникальный идентификатор продажи/возврата. <ul>  <li> `SXXXXXXXXXX` — продажа  <li> `RXXXXXXXXXX` — возврат  <li> `DXXXXXXXXXXX` — доплата <li> `AXXXXXXXXX` – сторно продаж (все значения полей как у продажи, но поля с суммами и кол-вом с минусом как в возврате) <li> `BXXXXXXXXX` - сторно возврата (все значения полей как у возврата, но поля с суммами и кол-вом с плюсом, в противоположность возврату) </ul>
	SaleID *string `json:"saleID,omitempty"`

	// Spp Согласованная скидка постоянного покупателя
	Spp *float32 `json:"spp,omitempty"`

	// Srid Уникальный идентификатор заказа, функционально аналогичный `odid`/`rid`.  Данный параметр введен в июле'22 и в течение переходного периода может быть заполнен не во всех ответах. Примечание для работающих по системе Маркетплейс: `srid` равен `rid` в ответе на метод `GET /api/v2/orders`.
	Srid *string `json:"srid,omitempty"`

	// Sticker Цифровое значение стикера, который клеится на товар в процессе сборки заказа по системе Маркетплейс.
	Sticker *string `json:"sticker,omitempty"`

	// Subject Предмет
	Subject *string `json:"subject,omitempty"`

	// SupplierArticle Артикул поставщика
	SupplierArticle *string `json:"supplierArticle,omitempty"`

	// TechSize Размер
	TechSize *string `json:"techSize,omitempty"`

	// TotalPrice Цена до согласованной скидки/промо/спп. Для получения цены со скидкой можно воспользоваться формулой `priceWithDiscount = totalPrice * (1 - discountPercent/100)`
	TotalPrice *float64 `json:"totalPrice,omitempty"`

	// WarehouseName Название склада отгрузки
	WarehouseName *string `json:"warehouseName,omitempty"`
}

// StocksItem defines model for StocksItem.
type StocksItem struct {
	// Discount Скидка
	Discount *float32 `json:"Discount,omitempty"`

	// Price Цена
	Price *float32 `json:"Price,omitempty"`

	// SCCode Код контракта
	SCCode *string `json:"SCCode,omitempty"`

	// Barcode Бар-код
	Barcode *string `json:"barcode,omitempty"`

	// Brand Бренд
	Brand *string `json:"brand,omitempty"`

	// Category Категория
	Category *string `json:"category,omitempty"`

	// DaysOnSite Количество дней на сайте
	DaysOnSite *int `json:"daysOnSite,omitempty"`

	// IsRealization Договор реализации
	IsRealization *bool `json:"isRealization,omitempty"`

	// IsSupply Договор поставки
	IsSupply *bool `json:"isSupply,omitempty"`

	// LastChangeDate Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе. Если часовой пояс не указан, то берется Московское время UTC+3.
	LastChangeDate *types.CustomTime `json:"lastChangeDate,omitempty"`

	// NmId Код WB
	NmId *int `json:"nmId,omitempty"`

	// Quantity Количество, доступное для продажи (сколько можно добавить в корзину)
	Quantity *int `json:"quantity,omitempty"`

	// QuantityFull Полное (непроданное) количество, которое числится за складом (= `quantity` + в пути)
	QuantityFull *int `json:"quantityFull,omitempty"`

	// Subject Предмет
	Subject *string `json:"subject,omitempty"`

	// SupplierArticle Артикул поставщика
	SupplierArticle *string `json:"supplierArticle,omitempty"`

	// TechSize Размер
	TechSize *string `json:"techSize,omitempty"`

	// WarehouseName Название склада
	WarehouseName *string `json:"warehouseName,omitempty"`
}

// DateFrom defines model for dateFrom.
type DateFrom = types.CustomTime

// DateTo defines model for dateTo.
type DateTo = types.CustomTime

// Flag defines model for flag.
type Flag = int

// GetWBOrdersParams defines parameters for GetWBOrders.
type GetWBOrdersParams struct {
	// DateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера `Z` в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). <br>Примеры: <ul> <li> `2019-06-20` <li> `2019-06-20T00:00:00Z` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345Z` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>
	DateFrom DateFrom `form:"dateFrom" json:"dateFrom"`
	Flag     *Flag    `form:"flag,omitempty" json:"flag,omitempty"`
}

// GetWBReportDetailByPeriodParams defines parameters for GetWBReportDetailByPeriod.
type GetWBReportDetailByPeriodParams struct {
	// DateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера `Z` в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). <br>Примеры: <ul> <li> `2019-06-20` <li> `2019-06-20T00:00:00Z` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345Z` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>
	DateFrom DateFrom `form:"dateFrom" json:"dateFrom"`
	DateTo   DateTo   `form:"dateTo" json:"dateTo"`

	// Limit Количество записей на странице
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Rrdid Идентификатор отчета
	Rrdid *int `form:"rrdid,omitempty" json:"rrdid,omitempty"`
}

// GetWBSalesParams defines parameters for GetWBSales.
type GetWBSalesParams struct {
	// DateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера `Z` в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). <br>Примеры: <ul> <li> `2019-06-20` <li> `2019-06-20T00:00:00Z` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345Z` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>
	DateFrom DateFrom `form:"dateFrom" json:"dateFrom"`
	Flag     *Flag    `form:"flag,omitempty" json:"flag,omitempty"`
}

// GetSupplierStocksParams defines parameters for GetSupplierStocks.
type GetSupplierStocksParams struct {
	// DateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера `Z` в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). <br>Примеры: <ul> <li> `2019-06-20` <li> `2019-06-20T00:00:00Z` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345Z` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul>
	DateFrom DateFrom `form:"dateFrom" json:"dateFrom"`
}

// GetOzonSupplierStocksJSONBody defines parameters for GetOzonSupplierStocks.
type GetOzonSupplierStocksJSONBody struct {
	Limit         *int                                        `json:"limit,omitempty"`
	Offset        *int                                        `json:"offset,omitempty"`
	WarehouseType *GetOzonSupplierStocksJSONBodyWarehouseType `json:"warehouse_type,omitempty"`
}

// GetOzonSupplierStocksJSONBodyWarehouseType defines parameters for GetOzonSupplierStocks.
type GetOzonSupplierStocksJSONBodyWarehouseType string

// GetOzonSupplierStocksJSONRequestBody defines body for GetOzonSupplierStocks for application/json ContentType.
type GetOzonSupplierStocksJSONRequestBody GetOzonSupplierStocksJSONBody

// GetOzonFBOJSONRequestBody defines body for GetOzonFBO for application/json ContentType.
type GetOzonFBOJSONRequestBody = FBOFilter

// GetOzonProductInfoJSONRequestBody defines body for GetOzonProductInfo for application/json ContentType.
type GetOzonProductInfoJSONRequestBody = ProductFilter

// GetOzonProductAttributesJSONRequestBody defines body for GetOzonProductAttributes for application/json ContentType.
type GetOzonProductAttributesJSONRequestBody = ProductAttributeFilter

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetWBOrders request
	GetWBOrders(ctx context.Context, params *GetWBOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWBReportDetailByPeriod request
	GetWBReportDetailByPeriod(ctx context.Context, params *GetWBReportDetailByPeriodParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWBSales request
	GetWBSales(ctx context.Context, params *GetWBSalesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupplierStocks request
	GetSupplierStocks(ctx context.Context, params *GetSupplierStocksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOzonSupplierStocksWithBody request with any body
	GetOzonSupplierStocksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOzonSupplierStocks(ctx context.Context, body GetOzonSupplierStocksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOzonFBOWithBody request with any body
	GetOzonFBOWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOzonFBO(ctx context.Context, body GetOzonFBOJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOzonProductInfoWithBody request with any body
	GetOzonProductInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOzonProductInfo(ctx context.Context, body GetOzonProductInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOzonProductAttributesWithBody request with any body
	GetOzonProductAttributesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOzonProductAttributes(ctx context.Context, body GetOzonProductAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetWBOrders(ctx context.Context, params *GetWBOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWBOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWBReportDetailByPeriod(ctx context.Context, params *GetWBReportDetailByPeriodParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWBReportDetailByPeriodRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWBSales(ctx context.Context, params *GetWBSalesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWBSalesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupplierStocks(ctx context.Context, params *GetSupplierStocksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupplierStocksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonSupplierStocksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonSupplierStocksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonSupplierStocks(ctx context.Context, body GetOzonSupplierStocksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonSupplierStocksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonFBOWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonFBORequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonFBO(ctx context.Context, body GetOzonFBOJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonFBORequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonProductInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonProductInfoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonProductInfo(ctx context.Context, body GetOzonProductInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonProductInfoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonProductAttributesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonProductAttributesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOzonProductAttributes(ctx context.Context, body GetOzonProductAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOzonProductAttributesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetWBOrdersRequest generates requests for GetWBOrders
func NewGetWBOrdersRequest(server string, params *GetWBOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/supplier/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFrom", runtime.ParamLocationQuery, params.DateFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Flag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flag", runtime.ParamLocationQuery, *params.Flag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWBReportDetailByPeriodRequest generates requests for GetWBReportDetailByPeriod
func NewGetWBReportDetailByPeriodRequest(server string, params *GetWBReportDetailByPeriodParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/supplier/reportDetailByPeriod")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFrom", runtime.ParamLocationQuery, params.DateFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateTo", runtime.ParamLocationQuery, params.DateTo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rrdid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rrdid", runtime.ParamLocationQuery, *params.Rrdid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWBSalesRequest generates requests for GetWBSales
func NewGetWBSalesRequest(server string, params *GetWBSalesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/supplier/sales")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFrom", runtime.ParamLocationQuery, params.DateFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Flag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flag", runtime.ParamLocationQuery, *params.Flag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSupplierStocksRequest generates requests for GetSupplierStocks
func NewGetSupplierStocksRequest(server string, params *GetSupplierStocksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/supplier/stocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFrom", runtime.ParamLocationQuery, params.DateFrom); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOzonSupplierStocksRequest calls the generic GetOzonSupplierStocks builder with application/json body
func NewGetOzonSupplierStocksRequest(server string, body GetOzonSupplierStocksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOzonSupplierStocksRequestWithBody(server, "application/json", bodyReader)
}

// NewGetOzonSupplierStocksRequestWithBody generates requests for GetOzonSupplierStocks with any type of body
func NewGetOzonSupplierStocksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/analytics/stock_on_warehouses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOzonFBORequest calls the generic GetOzonFBO builder with application/json body
func NewGetOzonFBORequest(server string, body GetOzonFBOJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOzonFBORequestWithBody(server, "application/json", bodyReader)
}

// NewGetOzonFBORequestWithBody generates requests for GetOzonFBO with any type of body
func NewGetOzonFBORequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/posting/fbo/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOzonProductInfoRequest calls the generic GetOzonProductInfo builder with application/json body
func NewGetOzonProductInfoRequest(server string, body GetOzonProductInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOzonProductInfoRequestWithBody(server, "application/json", bodyReader)
}

// NewGetOzonProductInfoRequestWithBody generates requests for GetOzonProductInfo with any type of body
func NewGetOzonProductInfoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/product/info/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOzonProductAttributesRequest calls the generic GetOzonProductAttributes builder with application/json body
func NewGetOzonProductAttributesRequest(server string, body GetOzonProductAttributesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOzonProductAttributesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetOzonProductAttributesRequestWithBody generates requests for GetOzonProductAttributes with any type of body
func NewGetOzonProductAttributesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/products/info/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetWBOrdersWithResponse request
	GetWBOrdersWithResponse(ctx context.Context, params *GetWBOrdersParams, reqEditors ...RequestEditorFn) (*GetWBOrdersResponse, error)

	// GetWBReportDetailByPeriodWithResponse request
	GetWBReportDetailByPeriodWithResponse(ctx context.Context, params *GetWBReportDetailByPeriodParams, reqEditors ...RequestEditorFn) (*GetWBReportDetailByPeriodResponse, error)

	// GetWBSalesWithResponse request
	GetWBSalesWithResponse(ctx context.Context, params *GetWBSalesParams, reqEditors ...RequestEditorFn) (*GetWBSalesResponse, error)

	// GetSupplierStocksWithResponse request
	GetSupplierStocksWithResponse(ctx context.Context, params *GetSupplierStocksParams, reqEditors ...RequestEditorFn) (*GetSupplierStocksResponse, error)

	// GetOzonSupplierStocksWithBodyWithResponse request with any body
	GetOzonSupplierStocksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonSupplierStocksResponse, error)

	GetOzonSupplierStocksWithResponse(ctx context.Context, body GetOzonSupplierStocksJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonSupplierStocksResponse, error)

	// GetOzonFBOWithBodyWithResponse request with any body
	GetOzonFBOWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonFBOResponse, error)

	GetOzonFBOWithResponse(ctx context.Context, body GetOzonFBOJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonFBOResponse, error)

	// GetOzonProductInfoWithBodyWithResponse request with any body
	GetOzonProductInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonProductInfoResponse, error)

	GetOzonProductInfoWithResponse(ctx context.Context, body GetOzonProductInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonProductInfoResponse, error)

	// GetOzonProductAttributesWithBodyWithResponse request with any body
	GetOzonProductAttributesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonProductAttributesResponse, error)

	GetOzonProductAttributesWithResponse(ctx context.Context, body GetOzonProductAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonProductAttributesResponse, error)
}

type GetWBOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrdersItem
}

// Status returns HTTPResponse.Status
func (r GetWBOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWBOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWBReportDetailByPeriodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ReportDetailByPeriodItem
}

// Status returns HTTPResponse.Status
func (r GetWBReportDetailByPeriodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWBReportDetailByPeriodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWBSalesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SalesItem
}

// Status returns HTTPResponse.Status
func (r GetWBSalesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWBSalesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupplierStocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]StocksItem
}

// Status returns HTTPResponse.Status
func (r GetSupplierStocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupplierStocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOzonSupplierStocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *struct {
			Rows *[]RowItem `json:"rows,omitempty"`
		} `json:"result,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOzonSupplierStocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOzonSupplierStocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOzonFBOResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]FBO `json:"result,omitempty"`
	}
	JSON400 *OzonError
	JSON403 *OzonError
	JSON404 *OzonError
	JSON409 *OzonError
	JSON500 *OzonError
}

// Status returns HTTPResponse.Status
func (r GetOzonFBOResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOzonFBOResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOzonProductInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *struct {
			Items *[]ProductInfo `json:"items,omitempty"`
		} `json:"result,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOzonProductInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOzonProductInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOzonProductAttributesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LastId *string             `json:"last_id,omitempty"`
		Result *[]ProductAttribute `json:"result,omitempty"`
		Total  *int                `json:"total,omitempty"`
	}
	JSON404 *OzonError
}

// Status returns HTTPResponse.Status
func (r GetOzonProductAttributesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOzonProductAttributesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetWBOrdersWithResponse request returning *GetWBOrdersResponse
func (c *ClientWithResponses) GetWBOrdersWithResponse(ctx context.Context, params *GetWBOrdersParams, reqEditors ...RequestEditorFn) (*GetWBOrdersResponse, error) {
	rsp, err := c.GetWBOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWBOrdersResponse(rsp)
}

// GetWBReportDetailByPeriodWithResponse request returning *GetWBReportDetailByPeriodResponse
func (c *ClientWithResponses) GetWBReportDetailByPeriodWithResponse(ctx context.Context, params *GetWBReportDetailByPeriodParams, reqEditors ...RequestEditorFn) (*GetWBReportDetailByPeriodResponse, error) {
	rsp, err := c.GetWBReportDetailByPeriod(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWBReportDetailByPeriodResponse(rsp)
}

// GetWBSalesWithResponse request returning *GetWBSalesResponse
func (c *ClientWithResponses) GetWBSalesWithResponse(ctx context.Context, params *GetWBSalesParams, reqEditors ...RequestEditorFn) (*GetWBSalesResponse, error) {
	rsp, err := c.GetWBSales(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWBSalesResponse(rsp)
}

// GetSupplierStocksWithResponse request returning *GetSupplierStocksResponse
func (c *ClientWithResponses) GetSupplierStocksWithResponse(ctx context.Context, params *GetSupplierStocksParams, reqEditors ...RequestEditorFn) (*GetSupplierStocksResponse, error) {
	rsp, err := c.GetSupplierStocks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupplierStocksResponse(rsp)
}

// GetOzonSupplierStocksWithBodyWithResponse request with arbitrary body returning *GetOzonSupplierStocksResponse
func (c *ClientWithResponses) GetOzonSupplierStocksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonSupplierStocksResponse, error) {
	rsp, err := c.GetOzonSupplierStocksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonSupplierStocksResponse(rsp)
}

func (c *ClientWithResponses) GetOzonSupplierStocksWithResponse(ctx context.Context, body GetOzonSupplierStocksJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonSupplierStocksResponse, error) {
	rsp, err := c.GetOzonSupplierStocks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonSupplierStocksResponse(rsp)
}

// GetOzonFBOWithBodyWithResponse request with arbitrary body returning *GetOzonFBOResponse
func (c *ClientWithResponses) GetOzonFBOWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonFBOResponse, error) {
	rsp, err := c.GetOzonFBOWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonFBOResponse(rsp)
}

func (c *ClientWithResponses) GetOzonFBOWithResponse(ctx context.Context, body GetOzonFBOJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonFBOResponse, error) {
	rsp, err := c.GetOzonFBO(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonFBOResponse(rsp)
}

// GetOzonProductInfoWithBodyWithResponse request with arbitrary body returning *GetOzonProductInfoResponse
func (c *ClientWithResponses) GetOzonProductInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonProductInfoResponse, error) {
	rsp, err := c.GetOzonProductInfoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonProductInfoResponse(rsp)
}

func (c *ClientWithResponses) GetOzonProductInfoWithResponse(ctx context.Context, body GetOzonProductInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonProductInfoResponse, error) {
	rsp, err := c.GetOzonProductInfo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonProductInfoResponse(rsp)
}

// GetOzonProductAttributesWithBodyWithResponse request with arbitrary body returning *GetOzonProductAttributesResponse
func (c *ClientWithResponses) GetOzonProductAttributesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOzonProductAttributesResponse, error) {
	rsp, err := c.GetOzonProductAttributesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonProductAttributesResponse(rsp)
}

func (c *ClientWithResponses) GetOzonProductAttributesWithResponse(ctx context.Context, body GetOzonProductAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOzonProductAttributesResponse, error) {
	rsp, err := c.GetOzonProductAttributes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOzonProductAttributesResponse(rsp)
}

// ParseGetWBOrdersResponse parses an HTTP response from a GetWBOrdersWithResponse call
func ParseGetWBOrdersResponse(rsp *http.Response) (*GetWBOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWBOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrdersItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWBReportDetailByPeriodResponse parses an HTTP response from a GetWBReportDetailByPeriodWithResponse call
func ParseGetWBReportDetailByPeriodResponse(rsp *http.Response) (*GetWBReportDetailByPeriodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWBReportDetailByPeriodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ReportDetailByPeriodItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWBSalesResponse parses an HTTP response from a GetWBSalesWithResponse call
func ParseGetWBSalesResponse(rsp *http.Response) (*GetWBSalesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWBSalesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SalesItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSupplierStocksResponse parses an HTTP response from a GetSupplierStocksWithResponse call
func ParseGetSupplierStocksResponse(rsp *http.Response) (*GetSupplierStocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupplierStocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []StocksItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOzonSupplierStocksResponse parses an HTTP response from a GetOzonSupplierStocksWithResponse call
func ParseGetOzonSupplierStocksResponse(rsp *http.Response) (*GetOzonSupplierStocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOzonSupplierStocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *struct {
				Rows *[]RowItem `json:"rows,omitempty"`
			} `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOzonFBOResponse parses an HTTP response from a GetOzonFBOWithResponse call
func ParseGetOzonFBOResponse(rsp *http.Response) (*GetOzonFBOResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOzonFBOResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]FBO `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest OzonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OzonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest OzonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest OzonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest OzonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOzonProductInfoResponse parses an HTTP response from a GetOzonProductInfoWithResponse call
func ParseGetOzonProductInfoResponse(rsp *http.Response) (*GetOzonProductInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOzonProductInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *struct {
				Items *[]ProductInfo `json:"items,omitempty"`
			} `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOzonProductAttributesResponse parses an HTTP response from a GetOzonProductAttributesWithResponse call
func ParseGetOzonProductAttributesResponse(rsp *http.Response) (*GetOzonProductAttributesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOzonProductAttributesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LastId *string             `json:"last_id,omitempty"`
			Result *[]ProductAttribute `json:"result,omitempty"`
			Total  *int                `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest OzonError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
